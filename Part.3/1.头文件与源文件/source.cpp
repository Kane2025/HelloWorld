/*
* 这个.cpp后缀的就是我们的源文件 一般用来实现类里面的函数具体的细节
* 首先 我们要包含我们自己的头文件
* 记住 要使用引号哦
* 关于引号和尖括号有什么区别 你可以这么记:
* 系统自带的头文件用尖括号括起来，这样编译器会在系统文件目录下查找。
* 用户自定义的文件用双引号括起来，编译器首先会在用户目录下查找，然后在到C++安装目录中查找，最后在系统文件中查找。
* 太长不看版:
* 系统给你的用<> 你自己写的用""
*/

#include <iostream>
#include "header.h"

using std::cout;
using std::endl;

//当我们要具体实现一个类中的函数时 使用类名::函数名的形式即可
void A::print() {
	//我们让print输出abc的值
	cout << "a=" << this->a << "b=" << this->b << "c=" << this->c << endl;
}

//构造函数同理
A::A(int a, int b, int c) {
	this->a = a;
	this->b = b;
	this->c = c;
}

/* 这里我们讲一下构造函数的另一种初始化方式 列表初始化法
* 使用方法很简单 在函数名后面使用单个冒号即可
* 然后用变量名(值)的方式初始化 多个使用逗号隔开
* 使用这种方式初始化更快 所以也推荐用这种方式初始化
* 我们知道 如果我们声明一个变量 不给它默认值 比如 int i;
* 那么系统就会在运行时给它一个随机的值 这个值很可能是内存中的垃圾数据
* 用列表初始化可以很好的避免这个问题
* 如果你使用上面那种 赋值法 的话
* 其实系统已经给它赋值了一遍垃圾数据 然后你再给它赋值 相当于到你这就是二手的了
* 我们使用列表初始化法就是一手的了
*/
A::A() :
	a(0), b(0), c(0) {
}

/*
* 需要注意的是
* 列表初始化法 无论你这里填的顺序如何
* 他都会按照你在头文件声明变量的顺序来初始化
* 所以 当你要初始化的变量依靠另一个变量时 请把那个被依赖的变量提前
*/

//析构函数同理
A::~A() {
	cout << "awsl" << endl;
}